# Реализация пользовательского пула потоков

## Обзор

Данный проект представляет собой настраиваемый пул потоков для высоконагруженных серверных приложений, обеспечивающий детальный контроль над управлением потоками, очередями задач и политиками выполнения. Он разработан как альтернатива стандартному `ThreadPoolExecutor` с дополнительными возможностями.

## Ключевые особенности

- Настраиваемый базовый и максимальный размер пула
- Таймаут для неактивных рабочих потоков
- Множественные очереди задач с распределением по принципу Round Robin
- Политика минимального количества запасных потоков
- Детальное логирование выполнения
- Настраиваемые политики отказа

## Особенности реализации

### Архитектура пула потоков

Пул потоков состоит из следующих ключевых компонентов:

1. **Рабочие потоки (Worker Threads)**: Каждый рабочий поток связан с конкретной очередью задач и обрабатывает задачи из неё.
2. **Очереди задач**: Множественные ограниченные очереди распределяют нагрузку между рабочими потоками.
3. **Фабрика потоков**: Создаёт и именует рабочие потоки.
4. **Обработчик отказов**: Управляет отклонением задач при перегрузке пула.

### Механизм распределения задач

Задачи распределяются по принципу **Round Robin**:
- Каждая задача предлагается очередям в круговом порядке
- Это предотвращает превращение какой-либо очереди в узкое место
- Если все очереди заполнены, пул пытается создать новый рабочий поток (если количество потоков ниже maxPoolSize)
- Если нет доступных ресурсов, применяется политика отказа

### Управление жизненным циклом рабочих потоков

Рабочие потоки следуют следующим правилам:
- Базовые потоки остаются активными неопределённое время (если не вызван метод shutdown)
- Не-базовые потоки завершаются после простоя в течение keepAliveTime
- Если количество запасных потоков падает ниже minSpareThreads, создаются новые рабочие потоки
- Завершенные рабочие потоки автоматически заменяются, если размер пула падает ниже corePoolSize

### Обработка отказов

Политика отказа по умолчанию — AbortPolicy:
- Логирует отказ с предупреждением
- Бросает исключение RejectedExecutionException
- Данный подход был выбран, так как обеспечивает мгновенную обратную связь и предотвращает скрытые отказы

Альтернативные политики могут включать:
- CallerRuns: Выполнение задачи в потоке вызывающего
- Discard: Молчаливое отбрасывание задачи
- DiscardOldest: Удаление самой старой задачи и повторная попытка

## Анализ производительности

### Сравнение со стандартным ThreadPoolExecutor

Пользовательский пул предлагает несколько преимуществ:
- **Множественные очереди**: Снижает конкуренцию по сравнению с единой общей очередью
- **Минимум запасных потоков**: Более отзывчив при колеблющейся нагрузке
- **Обработка по очередям**: Лучшая локальность и эффективность кэша

Потенциальные недостатки:
- Более высокое потребление памяти из-за множественных структур очередей
- Более сложная реализация с повышенными затратами на обслуживание
- Накладные расходы на создание/уничтожение потоков, если параметры не оптимизированы

### Оптимальные параметры конфигурации

На основе тестирования, следующие параметры хорошо подходят для различных сценариев:

**Для IO-зависимых нагрузок:**
- Более высокое соотношение базовых к максимальным потокам (например, 8:16)
- Большие очереди (размер 100+)
- Более длительное время keepAliveTime (30-60 секунд)
- Низкое количество minSpareThreads (1-2)

**Для CPU-зависимых нагрузок:**
- Низкое соотношение базовых к максимальным потокам (базовые потоки равны количеству CPU)
- Меньшие очереди (размер 10-20)
- Короткое время keepAliveTime (5-10 секунд)
- Высокое количество minSpareThreads (cores/4)

**Для смешанных нагрузок:**
- Средний размер базовых потоков (количество CPU + 2)
- Средний размер очереди (25-50)
- Среднее время keepAliveTime (15-20 секунд)
- Среднее количество minSpareThreads (2-4)

## Сборка и запуск

### Требования

- Java 11 или выше
- Maven 3.6 или выше

### Сборка проекта

```bash
# Клонирование репозитория
git clone https://github.com/your-username/custom-thread-pool.git
cd custom-thread-pool

# Сборка с Maven
mvn clean package
```

### Запуск демонстрации

```bash
# Запуск с jar-файлом
java -jar target/custom-thread-pool-1.0-SNAPSHOT.jar

# Или запуск через classpath
java -cp target/classes ru.threadpool.Main
```

## Пример использования

```java
// Создание пула потоков с указанными параметрами
CustomThreadPool pool = new CustomThreadPool(
    4,                     // corePoolSize
    8,                     // maxPoolSize
    30,                    // keepAliveTime
    TimeUnit.SECONDS,      // timeUnit
    50,                    // queueSize
    2                      // minSpareThreads
);

// Отправка задач
pool.execute(() -> {
    // Реализация задачи
});

// Отправка задач с результатом
Future<String> result = pool.submit(() -> {
    // Реализация Callable
    return "результат";
});

// Завершение работы пула
pool.shutdown();
```

## Будущие улучшения

Потенциальные улучшения для данной реализации:
- Поддержка приоритетов задач
- Алгоритм распределения по наименее загруженной очереди
- Афинность рабочих потоков для лучшей локальности кэша
- Более сложные возможности мониторинга
- Адаптивное изменение размера на основе исторических данных о нагрузке 